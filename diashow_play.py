#! /Users/xhalc/python-venv/.venv/bin/python3

# 'diashow_play.py'
# takes a JSON list of absolute image paths,
# e.g. generated by 'diashow_mdfind.py'
# displays the images in a PyQt6 window
# you need to 'pip install PyQt6'

from __future__ import annotations
import sys, pathlib, tomllib, argparse, json
from dataclasses import dataclass
from typing import List

from PyQt6.QtCore import Qt, QTimer, QElapsedTimer
from PyQt6.QtGui import (
    QKeyEvent,
    QPixmap,
    QImage,
    QPainter,
    QColor,
    QPalette,
)
from PyQt6.QtWidgets import (
    QApplication,
    QLabel,
    QMainWindow,
    QMessageBox,
    QSizePolicy,
)


# ANSI SGR formatting sequences
def ft(code) -> str:
    return '\x1b[' + str(code) + 'm'
def fc(code) -> str:
    return ft('38;5;' + str(code))

# formatted warnings
def warn(msg):
    print(fc(196) + str(msg) + ft(0), file=sys.stderr)

# read configuration file
def read_configuration(my_path: pathlib.Path) -> dict:
    config_path = my_path.with_suffix('.toml')
    try:
        with open(config_path, 'rb') as f:
            return tomllib.load(f)
    except Exception as e:
        warn('TOML error: ' + str(e))
        return {}

# parse arguments
def get_arguments(my_name: str) -> argparse.Namespace:
    parser = argparse.ArgumentParser(prog=my_name)
    parser.add_argument('parameter',
                        type=str,
                        help='parameter help')
    parser.add_argument('--option',
                        action='store_true',
                        required=False,
                        help='option help')
    return parser.parse_args()

# Slides class
@dataclass(frozen=True)
class Slides:
    paths: List[pathlib.Path]

    @staticmethod
    def load_from_file(path: pathlib.Path) -> 'Slides':
        if not path.exists():
            raise FileNotFoundError(f'file not found: {path}')
        try:
            data = json.loads(path.read_text(encoding='utf-8'))
        except json.JSONDecodeError as e:
            raise ValueError(f'broken json in {path}: {e}') from e
        if not isinstance(data, list) or not all(isinstance(x, str) for x in data):
            raise ValueError(f'{path} is not a list of strings')
        paths = [pathlib.Path(p) for p in data]
        if not paths:
            raise ValueError(f'{path} is empty')
        return Slides(paths=paths)

# SlideshowWindow class
class SlideshowWindow(QMainWindow):
    _TRANSITION_MS = 333
    _TRANSITION_FRAME_MS = 16

    def __init__(self, slides: Slides, timer_seconds: float) -> None:
        super().__init__()
        self.setWindowTitle('Diashow')
        self._slides = slides
        self._timer_seconds = timer_seconds
        self._index = 0
        self._label = QLabel(alignment=Qt.AlignmentFlag.AlignCenter) # type: ignore
        self._label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        #self._label.setAutoFillBackground(True)
        #self._label.setStyleSheet('background: white;')
        self.setCentralWidget(self._label)
        self.setCursor(Qt.CursorShape.BlankCursor)  # hide mouse cursor
        self._pixmap_original: QPixmap | None = None
        self._transition_from: QPixmap | None = None
        self._transition_to: QPixmap | None = None
        self._transition_target_index: int | None = None
        self._transition_elapsed = QElapsedTimer()

        self._transition_timer = QTimer(self)
        self._transition_timer.timeout.connect(self._transition_step)

        self._timer = QTimer(self)
        self._timer.timeout.connect(self._advance_by_timer)
        self._load_current_image()

    def _load_image_at_index(self, index: int) -> QPixmap | None:
        path = self._slides.paths[index]
        pix = QPixmap(str(path))
        if pix.isNull():
            QMessageBox.warning(self, 'error:', f'could not load image:\n{path}')
            self._label.setText(f'error while loading:\n{path}')
            return None
        img = pix.toImage().convertToFormat(QImage.Format.Format_ARGB32)
        bg = QImage(img.size(), QImage.Format.Format_ARGB32)
        bg.fill(Qt.GlobalColor.white)
        painter = QPainter(bg)
        painter.drawImage(0, 0, img)
        painter.end()
        return QPixmap.fromImage(bg)

    def _load_current_image(self) -> None:
        self._stop_transition()
        self._pixmap_original = self._load_image_at_index(self._index)
        self._update_view()

    def _stop_transition(self) -> None:
        self._transition_timer.stop()
        self._transition_from = None
        self._transition_to = None
        self._transition_target_index = None

    def _render_transition_frame(self, progress: float) -> None:
        if self._transition_from is None or self._transition_to is None:
            return
        target_size = self._label.size()
        if target_size.width() <= 0 or target_size.height() <= 0:
            return

        canvas = QImage(target_size, QImage.Format.Format_ARGB32)
        canvas.fill(Qt.GlobalColor.black)
        painter = QPainter(canvas)
        painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform, True)

        from_scaled = self._transition_from.scaled(
            target_size,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation,
        )
        to_scaled = self._transition_to.scaled(
            target_size,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation,
        )

        from_x = (target_size.width() - from_scaled.width()) // 2
        from_y = (target_size.height() - from_scaled.height()) // 2
        to_x = (target_size.width() - to_scaled.width()) // 2
        to_y = (target_size.height() - to_scaled.height()) // 2

        painter.setOpacity(1.0 - progress)
        painter.drawPixmap(from_x, from_y, from_scaled)
        painter.setOpacity(progress)
        painter.drawPixmap(to_x, to_y, to_scaled)
        painter.end()

        self._label.setPixmap(QPixmap.fromImage(canvas))

    def _transition_step(self) -> None:
        progress = min(1.0, self._transition_elapsed.elapsed() / self._TRANSITION_MS)
        self._render_transition_frame(progress)
        if progress >= 1.0:
            if self._transition_target_index is not None:
                self._index = self._transition_target_index
            self._pixmap_original = self._transition_to
            self._stop_transition()
            self._update_view()

    def _update_view(self) -> None:
        if self._pixmap_original is None:
            return
        target_size = self._label.size()
        scaled = self._pixmap_original.scaled(
            target_size,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation,
        )
        self._label.setPixmap(scaled)
        total = len(self._slides.paths)
        current = self._index + 1
        self.setWindowTitle(f'Diashow {current}/{total}  {self._slides.paths[self._index]}')

    def resizeEvent(self, event) -> None: # type: ignore
        super().resizeEvent(event)
        if self._transition_timer.isActive():
            progress = min(1.0, self._transition_elapsed.elapsed() / self._TRANSITION_MS)
            self._render_transition_frame(progress)
            return
        self._update_view()

    # left and right keys to move through the list of images
    def keyPressEvent(self, event: QKeyEvent) -> None: # type: ignore
        key = event.key()
        if key == Qt.Key.Key_Right:
            self._next()
        elif key == Qt.Key.Key_Left:
            self._prev()
        elif key == Qt.Key.Key_Space:
            self._toggle_timer()
        else:
            super().keyPressEvent(event)

    def _toggle_timer(self) -> None:
        if self._timer.isActive():
            self._timer.stop()
            return
        if self._timer_seconds <= 0:
            return
#       if self._index >= len(self._slides.paths) - 1:
#           return
        self._timer.start(int(self._timer_seconds * 1000))

    def _advance_by_timer(self) -> None:
        if self._transition_timer.isActive() or self._pixmap_original is None:
            return
        next_index = (self._index + 1) % len(self._slides.paths)
        next_pixmap = self._load_image_at_index(next_index)
        if next_pixmap is None:
            return
        self._transition_from = self._pixmap_original
        self._transition_to = next_pixmap
        self._transition_target_index = next_index
        self._transition_elapsed.start()
        self._transition_timer.start(self._TRANSITION_FRAME_MS)
        self._transition_step()

    def _next(self) -> None:
        self._stop_transition()
        if self._index < len(self._slides.paths) - 1:
            self._index += 1
            self._load_current_image()

    def _prev(self) -> None:
        self._stop_transition()
        if self._index > 0:
            self._index -= 1
            self._load_current_image()

# dark theme
def apply_dark_theme(app: QApplication) -> None:
    app.setStyle("Fusion")
    p = QPalette()
    #p.setColor(QPalette.ColorRole.Window, QColor(30, 30, 30))
    p.setColor(QPalette.ColorRole.Window, QColor(0, 0, 0))
    p.setColor(QPalette.ColorRole.WindowText, QColor(220, 220, 220))
    p.setColor(QPalette.ColorRole.Base, QColor(25, 25, 25))
    p.setColor(QPalette.ColorRole.AlternateBase, QColor(35, 35, 35))
    p.setColor(QPalette.ColorRole.ToolTipBase, QColor(220, 220, 220))
    p.setColor(QPalette.ColorRole.ToolTipText, QColor(220, 220, 220))
    p.setColor(QPalette.ColorRole.Text, QColor(220, 220, 220))
    p.setColor(QPalette.ColorRole.Button, QColor(45, 45, 45))
    p.setColor(QPalette.ColorRole.ButtonText, QColor(220, 220, 220))
    p.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    p.setColor(QPalette.ColorRole.Link, QColor(80, 160, 255))
    p.setColor(QPalette.ColorRole.Highlight, QColor(80, 160, 255))
    p.setColor(QPalette.ColorRole.HighlightedText, QColor(0, 0, 0))
    app.setPalette(p)

# main program
def main() -> int:
    # my path
    my_path = pathlib.Path(__file__)
    my_dir  = my_path.parent
    my_name = my_path.name

    config = read_configuration(my_path)

    timer = float(config['timer'])

    #arguments = get_arguments(my_name)

    slides_file = pathlib.Path(config['slidesfile'])

    try:
        slides = Slides.load_from_file(slides_file)
        if not slides:
            warn('no slides in: ' + str(slides_file))
    except Exception as e:
        print(f'error: {e}', file=sys.stderr)
        return 1

    app = QApplication(sys.argv)
    apply_dark_theme(app)
    win = SlideshowWindow(slides, timer)
    #win.resize(1280, 720)
    #win.showMaximized()
    win.showFullScreen()
    #win.show()
    return app.exec()

if __name__ == '__main__':
    sys.exit(main())
